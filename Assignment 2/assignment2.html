<!DOCTYPE html>
<html>
  <head>
    <!--added PixiJS Library-->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/pixi.js/4.8.2/pixi.min.js"></script>
  </head>
  <body>
    <!--no white border-->
    <style>* {padding: 0; margin: 0}</style>
    <script type="text/javascript">
        //By creating aliases to frequently used methods you save yourself some time
        //If the library is updated and something changes then you just change the definition of your aliases
        //aliases
        let Application = PIXI.Application,
            Container = PIXI.Container,
            loader = PIXI.loader,
            Sprite = PIXI.Sprite,
            Graphics = PIXI.Graphics,
            resources = PIXI.loader.resources;

        //Create a Pixi Application (this replaces the initiaization of the canvas because it appends it below(this is our canvas now))
        //whatever is in between the  {} are the options object, you can add as many as you want
        //instead of using # for color, use 0x---
        //antialias smoothes the edges of the letters and graphic primitives (not available in all platforms)
        let app = new Application({width: 900, height: 700, antialias: true, backgroundColor: 0x42cef4});

        //Use CSS styling to make the canvas fullscreen
        app.renderer.view.style.position = "absolute";
        app.renderer.view.style.display = "block";
        app.renderer.autoResize = true;
        app.renderer.resize(window.innerWidth, window.innerHeight);

        //Add the canvas that Pixi automatically created for you to the HTML document
        document.body.appendChild(app.view);

        let renderViewW = app.renderer.view.width,
        renderViewH = app.renderer.view.height;

        //define an empty array for the targets
        let targetImages = ["redTarget.png","yellowTarget.png","blueTarget.png"],
            numberOfTargets = 1;


        //use the loader to convert any image into a texture that webgl can render
        //you can load multiple images by adding more .add methods and array of .add images or json files
        loader
          .add("images/gameSprites.json")
          //.add("images/anotherImage.png")
          .load(setup);

        let state, yBalls, gameScene, id, triangle;

        //initialize sprite on set up
        function setup() {

          gameScene = new Container();
          app.stage.addChild(gameScene);


          //remember the order of things, if they do not exist first they won't be found
          id = PIXI.loader.resources["images/gameSprites.json"].textures;

          let yellowBall = new Sprite(
            id["yellowball.png"]
          );

          //Create an array of balls
          let noOfYellowBalls = 5,
          speed = 2,
          direction = 1;
          //Create the array of yellow balls
          yBalls = [];

          targetFunction();

          //create a for loop to call the balls
          for (let i = 0; i < noOfYellowBalls; i++) {
            //Call the ID to use the picture
           yellowBall = new Sprite(id["yellowball.png"]);

           //ball dimension is half of its original size
           yellowBall.scale.set(0.5,0.5);

           //ball anchor point is the center
           yellowBall.anchor.set(0.5, 0.5);

           //X and Y position
           yellowBall.position.set(renderViewW/2,renderViewH/2);

            //yellowBall.vX = 0;

            //Velocity
          //  yellowBall.vY = 0;
            direction *= -1;

            //Push the balls into the array

            yellowBall.interactive = true;
            yellowBall.buttonMode = true;

            // events for drag start
            yellowBall.on('mousedown', onDragStart)
            yellowBall.on('touchstart', onDragStart)
            // events for drag end
            yellowBall.on('mouseup', onDragEnd)
            yellowBall.on('mouseupoutside', onDragEnd)
            yellowBall.on('touchend', onDragEnd)
            yellowBall.on('touchendoutside', onDragEnd)
            // events for drag move
            yellowBall.on('mousemove', onDragMove)
            yellowBall.on('touchmove', onDragMove);



            //Add the ball into the gamescene
            gameScene.addChild(yellowBall);



          }





          state = play;

          //Start the game loop
          app.ticker.add(delta => gameLoop(delta));
        }

        function gameLoop(delta){

          state(delta);

        }

        function play(delta) {
         yBalls.forEach(function(yellowBall) {
            yellowBall.vX = 3;
            yellowBall.x += yellowBall.vX;
        });

        }
      function missed(sprite, container) {
        //Leave the function undefined if it has not collided with anything
        let noTarget = undefined;
        //contain takes two arguments. The first is the sprite you want to keep contained
        // The second is any object with x, y, width and height properties
        //that define a rectangular area
        //The function will check if the ball has left the area.

        //We also check in the function if the sprite has collieded with
        //Any other object, noTarget then changes based on which side
        //The sprite has collided with.
        if (sprite.x < container.x+30) {
          sprite.x = container.x;
          noTarget = "left";
        }

        //Top
        if (sprite.y < container.y) {
          sprite.y = container.y;
          noTarget = "top";
        }

        //Right
        if (sprite.x + sprite.width > container.width) {
          sprite.x = container.width - sprite.width;
          noTarget = "right";
        }

        //Bottom
        if (sprite.y + sprite.height > container.height) {
          sprite.y = container.height - sprite.height;
          noTarget = "bottom";
        }

        //Return the `collision` value
        return noTarget;

      }

      function onDragStart(event){
          // store a reference to the data
          // the reason for this is because of multitouch
          // we want to track the movement of this particular touch
          this.data = event.data;
          this.dragging = true;
          //Append the array to add another ball
          //gameScene.addChild(yellowBall);

          console.log("added child");
      }

      function onDragEnd() {
          this.dragging = false;
      }

      function onDragMove(){
        if (this.dragging){
        let newPosition = this.data.getLocalPosition(this.parent);
        this.position.x = newPosition.x;
        this.position.y = newPosition.y;

    }
}
        function createTriangle(xPos, yPos, i){
        let triangle = new PIXI.Graphics();

        triangle.x = xPos;
        triangle.y = yPos;

        let triangleWidth = 100,
            triangleHeight = triangleWidth,
            triangleHalfway = triangleWidth/2;

        // draw triangle
        triangle.beginFill(0xFF0000, 1);
        triangle.lineStyle(0, 0xFF0000, 1);
        triangle.moveTo(triangleWidth, 0);
        triangle.lineTo(triangleHalfway, triangleHeight);
        triangle.lineTo(0, 0);
        triangle.lineTo(triangleHalfway, 0);
        triangle.endFill();

        triangle.interactive = true;
        triangle.buttonMode = true;
        triangle.on("pointertap", function(e) {
          console.log(i);
        });
      }


        //IMPORTANT
        //if you want to change the texture the sprite is displaying, use the texture property. Set it to any Texture object, like this:
        //anySprite.texture = PIXI.utils.TextureCache["anyTexture.png"];
        //targetFunction();

        let target,
            targetX,
            targetY;

        let targetFunction = function(){
          /*-- TARGETS HANDLING STARTS--*/
          //define global target

          //as long as i is less than the number of targets
          for(let i = 0; i<numberOfTargets; i++){

            //get a random integer between 0 and 2
            function getRandomInt(min,max){

              min = Math.ceil(min);
              max = Math.floor(max);

              return Math.floor(Math.random()* (max - min)) + min;
            }

            targetX = getRandomInt(0,renderViewW);
            targetY = getRandomInt(0,renderViewH/2-50);


              //the target image will be random
              target = new Sprite(id[targetImages[getRandomInt(0,3)]]);
              //position target at 50,50 and display
              target.position.set(targetX,targetY);
              target.scale.set(0.75,0.75);
              gameScene.addChild(target);
              console.log("this is target "+i)
          }

          /*--TARGET HANDLING ENDS--*/
        }
    </script>
  </body>
</html>
